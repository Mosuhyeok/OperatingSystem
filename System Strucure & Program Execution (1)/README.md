# System Strucure & Program Execution (1)

**메모리는 CPU의 작업공간.**

**CPU의 매 클럭마다 메모리에서 IR을 읽어서 실행한다.**

**I/O 장치는 각 I/O 디바이스마다 붙어있는 controller에 의해서 제어됨**

예) 디스크 → 디스크 컨트롤러가 제어

      키보드 → 키보드 컨트롤러가 제어

      cpu가 제어하는것이 아님 !

CPU안엔 레지스터, mode bit이 있다

mode bit은 cpu가 사용하는게 운영체제가 사용하는지, 사용자 프로그램인지 구분

CPU는 메모리 하고만 일한다.

메모리에서 키보드에서 읽어오고, printf처럼 출력, 디스크에서 값을 가져오는걸

I/O디바이스 접근이라고 하는데 CPU는 I/O디바이스를 직접 접근하지 않는다.

**CPU는 메모리에만 접근 !!!**

디스크에서 뭘 읽어오라는 요청은 어떻게 보내냐면 메모리에 올라와있는 프로그램 A가 

디스크에서 데이터를 요청하면 CPU가 직접 읽어오는 것이 아니라 읽어오라고 일을 시킨다

키보드 입력을 받을경우, CPU는 키보드controller에게 읽어오라고 일을 시키고 다 읽어 왔을시 cpu에게 알려달라고 함. 읽어오는건 I/O 출력이고 시간이 오래 걸리는 일이므로 CPU는 다른 할 일을 한다. 만약 A라는 프로그램이 scanf로 입력을 받고나서 진행을 해야하는 경우 CPU는 A프로그램이 아닌 다른 프로그램을 실행한다.

CPU는 매우 빠른 일꾼인데 쉬지않고 일을 해야한다.

A라는 프로그램이 I/O작업을 하지않고 무한루프를 도는 경우 계속 cpu를 독점한다.

이 경우 컴퓨터 안에 timer라는 하드웨어를 통해 사용한다

**timer는 특정 프로그램이 cpu를 독점하는것을 막는것**

CPU가 특정 프로그램을 실행할때 timer에 시간을 할당해서 주고 시간이 다 되면 다른 프로그램에게 cpu를 넘겨준다

CPU는 하나의 IR을 실행하고 끝나면 interrupt line을 체크한다

만약 timer가 interrupt line을 보내면 cpu는 하던일을 멈추고 cpu의 제어권이 사용자 프로그램에서 운영체제로 넘어간다.

![Untitled](System%20Str%2024b7d/Untitled.png)

**운영체제가 cpu를 얻게되면 다음 프로그램에 timer를 세팅하고 cpu를 넘겨준다.**

**사용자 프로그램은 직접 I/O를 접근 불가**. 보안상의 이유로

그래서 운영체제가 cpu를 잡고 I/O접근이 가능하다

사용자 프로그램이 I/O가 필요할 경우 스스로 운영체제에가 cpu를 넘겨주고 

운영체제가 CPU를 잡고 해당하는 작업을 I/O컨트롤러에게 요청한다.

프로그램은 I/O컨트롤러가 요청한 작업이 끝나고 cpu에게 인터럽트를 걸고

인터럽트가 걸리면 운영체제에게 cpu제어권이 넘어간다.

운영체제가 확인을 하고 해당 요청한 프로그램에게 I/O데이터를 넘겨주고 cpu를 넘겨준다.

mode bit은 cpu를 사용자 프로그램이 갖고있는지, 운영체제가 갖고있는지

mode bit =0 모니터모드 (=커널 모드 , 시스템모드) 

mode bit = 1 사용자 프로그램

mode bit이 0 일때는, 무슨일이든 다 할 수 있게 정의

메모리접근 뿐만 아니라 I/O접근도 가능, 운영체제가 cpu를 갖고 있으니

mode bit이 1일땐 제한된 IR만 가능. 

보안상의 목적. 

즉 OS에서 사용자 프로그램으로 cpu제어권이 넘길땐 mode bit을 1로 세팅하고 보내고

사용자프로그램에서 os로 갈땐 mode bit이 0 으로 세팅한다.

인터럽트가 발생 할 경우도 mode bit이 0

I/O장치에 의해 CPU가 너무 많이 인터럽트 당하면 효율적이지 않다

그래서 DMA Controller라는걸 둔다

**DMA : Direct Memory Acess**

직접 메모리에 접근할 수 있는 컨트롤러

원래는 메모리에 접근 할 수 있는건 CPU뿐이였지만 DMA 컨트롤러를 통해

CPU + DMA Controller 접근 가능

Memory Controller는 CPU가 메모리에 접근하는거와 DMA Controller가 동시 접근하는 것을 제어해줌

만약 동시 접근한다면 특정 프로그램에 데이터가 변경 됐을때 일관성이 깨질수도 있으므로

I/O장치가 인터럽트를 너무 많이걸면 CPU가 인터럽트를 너무 많이 당하고 

효율이 안좋다. DMA컨트롤러는 I/O장치에 있는 버퍼에 있는 내용을 한번에 가져온다

CPU에게 인터럽트를 걸어서 알려줌 → 인터럽트 빈도가 줄어들고 CPU의 효율이 높아짐

**I/O device Controller**

해당 I/O장치를 관리하는 일종의 작은 cpu

local buffer를 가짐 (I/O작업한 데이터를 보관)

device driver - > software

OS코드 중 각 장치별 I/O 처리 루틴

device controller → hardware

각 장치를 통제하는 일종의 작은 CPU

CPU는 register에 있는 pc로 해당 IR주소를 알고 실행하는 운명

### I/O의 수행

사용자 프로그램은 어떻게 I/O를 하는가?

**→ 시스템 콜 (사용자 프로그램이 운영체제(커널)의 함수 호출 (I/O요청) )**

**트랩(소프트웨어 인터럽트)**

사용자 프로그램이 돌아가다 시스템 콜을 해야 된다면

사용자 프로그램이 인터럽트를 걸고 cpu반납 하고 os로 넘어가게 하는걸

trap을 건다 라고 함

일반적인 인터럽트는 하드웨어 인터럽트

I/O요청을 하기위한 인터럽트 → 시스템콜 = 트랩

**인터럽트 관련 용어**

인터럽트 벡터

→ 인터럽트 종류는 많고 해당 인터럽트를 어떻게 처리해야 하는지

→ 해당 인터럽트의 처리 루틴 주소를 가지고 있음

→ 예를들어서 1번 인터럽트면 어떤 함수호출, 2번 인터럽트면 어떤 함수 호출

인터럽트 처리 루틴

→ 해당 인터럽트를 처리하는 커널 함수